类和动态内存分配

1 静态类成员：

静态类成员特点，无论创建多少个对象，程序都只创建一个静态类变量，类的所有对象共享同一个静态成员。，不能在类声明中初始化静态成员变量，这是因为类描述了如何分配内存，但并不分配内存。对于静态类成员，可以在类声明之外使用单独的语句来初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分，初始化语句指出了类型，并使用了作用域，但是没有使用关键字 static。

字符串并不是保存在内存对象中，字符串是单独保存在堆内存中。，对象仅保存了指出到哪里去查找字符串的信息。

在构造函数中使用new来分配内存，必须在析构函数中使用delete来释放内存。
如果使用new []申请内存，则应使用delete [] 释放内存。

特殊成员函数：
c++自动提供了下面这些成员函数：
1 默认构造函数，如果没有定义构造函数
2 默认析构函数，如果没有定义
3 复制构造函数，如果没有定义
4 赋值运算符，如果没有定义
5 地址运算符 如果没有定义。

默认构造函数
如果没有提供任何构造函数，c++ 将创建默认构造函数， 例如加入定义了类 Time，但是没有提供任何构造函数，则编译器将提供下述默认构造函数，
Time::Time()
{
	
}

也就是说编译器将提供一个不接受任何参数，也不执行任何操作的构造函数。

如果定义了构造函数，c++不会提供默认构造函数。如果希望在创建对象是不显示的对它进行初始化，则必须显式地定义默认构造函数。

换句话说如果定义了构造函数，则必须按照构造函数定义的参数形式初始化对象。例如构造函数提供了三个参数，则定义对象时也必须提供三个参数。否则则定义出错。

带有参数的构造函数也可以作为默认构造函数，只要所有参数都有默认值。 但是只能有一个默认构造函数。

2  复制构造函数

复制构造函数用于将一个对象复制到新建的对象中，也就是说，它用于初始化过程中 包括按值传递， 而不是常规的赋值过程中，类的复制构造函数原型如下：
class_name(const class_name & );

接收一个指向类对象的常量引用作为参数

对于复制构造函数需要知道两点：何时使用以及有何功能。

新建一个对象并将其初始化为同类型现有变量对象时，复制构造函数都将被使用。最常见的情况时将新对象显式的初始化为现有的对象。假设motto 是一个StringBag 对象，则下面4种声明都将调用复制构造函数：

StringBad ditto(motto)
StringBad metto = motto;
StringBad also = StringBad(motto)
StringBad *PstringBad = new StringBad(motto)

每当程序创建对象副本时，编译器都将使用复制构造函数，具体的说，当函数按值传递对象或者函数返回对象时，都将使用复制构造函数。

由于按值传递对象将调用复制构造函数，因此应该按引用传递对象，这样可以节省调用构造函数的时间以及存储新对象的空间。

默认的复制构造函数的功能：
默认的复制构造函数逐个复制非静态成员，复制的是成员的值。 成员复制也称为浅复制。

当类中含有成员变量是指针时， 默认构造函数只是将指针的值复制，而不会复制指针指向的内存。
假设
class {
	
	char * str;
}

这里复制的就是字符串的指针， 这样相当于两个对象的字符串指针指向同一个字符串，一旦其中一个对象调用析构函数释放，则有可能造成另一个对象指向的内存变为空。

解决类中这种问题的方法是进行深度复制（deep copy），也就是说复制构造函数应当复制字符串并将副本的地址赋给str 成员。而不仅仅是复制字符串地址。这样每个对象都有自己的字符串。而不是引用另一个对象的字符串。都用析构函数时都将释放不同的字符串。而不会试图去释放已经被释放的字符串。

赋值运算符：
将已有的对象赋值给另一个对象时，将使用重载的赋值运算符。

与复制构造函数类似，赋值运算符的隐式实现也是对成员进程逐个复制。但是静态数据成员不受影响。
解决赋值运算符的问题：
由于目标对象可能引用了以前分配的数据，所以函数应使用delete[] 来释放这些数据
函数应该避免将对象赋值给自身。
函数返回一个执行调用对象的引用。

c++11 空指针：
nullptr

中括号表示访问字符
对于中括号运算符，一个操作数位于第一个中括号的前面，另一个操作数位于两个中括号之间。city【2】， city是第一个操作数，2 是第二个操作数。

静态成员函数
可以将成员函数声明为静态的，函数声明必须包含关键字static， 如果函数定义是独立的，则其中不能包含关键字static。
首先不能通过对象调用静态成员函数，静态成员函数甚至不能使用this指针，如果静态成员函数在公有部分声明，则可以使用类名和作用域解析运算符来调用它。


有关返回对象的说明

返回指向const对象的引用
返回对象需要调用复制构造函数，返回引用则不会。 其次引用指向的对象应该在调用函数执行是存在， 传入的参数 都被声明为const ， 因此返回 const 引用更合理。

返回指向非const对象的引用
两种常见的返回非const对象情形是 重载赋值运算符以及重载于cout 一起使用的<<运算符。

返回对象
被重载的算术运算符属于这一类。

返回const对象



将 hour  miniute 以及 second 声明成private 变量，外部不可见。

其定义位于类声明中的函数都将自动成为内联函数，类声明常将短小的成员函数作为内联函数。

所创建的每个新对象都有自己的存储空间，用于存储内不变量和类成员，但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。
例如 kdate 和 joe 都是类 Time的对象， 则 kate.shares 将占据一个内存块，二joe.shares 将占据另一个内存块。
但是kate.show 与 joe.show 都调用同一个方法，也就是说他们将执行同一行代码，只是将这些代码用于不同的数据。



类小结：
类设计的第一步就是类声明，类声明类似结构声明，可以包括数据成员和成员函数。 声明私有部门的数据只能通过成员函数进行访问。
声明为共有部门的成员可以被使用类对象的程序直接访问。数据成员一般放在私有部分，成员函数放在公有部分。

典型的声明如下：
class classname
{
	private: 
		data member declarations
	public:
		member function prototypes

}

构造函数：

不要将类的成员名用作构造函数的参数名。
一种常见的做法是类成员名使用m_
另一种常见的做法是在成员中使用后缀_.
构造函数小结：
构造函数是一种特殊的类成员函数，在创建类对象时被调用，构造函数的名称与类名相同，但是通过函数重载，可以创建多个同名的构造函数，条件是每个函数的参数列表都不相同，另外 构造函数没有声明类型，通常构造函数用于初始化类对象的成员，初始化应与构造函数的参数列表匹配。

默认构造函数没有参数，因此如果创建对象没有显示的初始化，则调用默认构造函数。如果程序没有提供任何构造函数，则编译器会为程序提供一个默认的构造函数。


如果构造函数使用了new，则必须提供使用delete的析构函数。


10.4  this 指针

this 指针指向用来调用成员函数的对象，this 被作为隐藏参数传递给方法。
每个成员函数 包括构造函数和析构函数 都有一个this 指针，this 指针指向调用对象，如果方法需要饮用整个调用对象，则可以使用表达式*this，在函数的括号后面使用const 限定符，则将this 限定为const，
这样将不能使用this 来修改对象的值。

返回类型为饮用意味这返回的是调用对象本身，而不是其副本。


10.5 对象数组
参考代码


10.6 类作用域

在类中定义的名称 如类数据成员名和类成员函数名的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。因此可以在不同类中使用相同的类成员名而不会引起冲突。
另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此，也就是说，要调用公有成员函数，必须通过对象。总之，在类声明或者成员函数定义中，可以使用未修饰的成员名称。就是调用sum一样。

使用类成员名时，必须根据上下文使用直接成员运算符(.) 间接成员运算符（->） 或者作用域解析运算符（::）

10.6.1 作用域内枚举

使用符号常量的作用域类很有用，例如类声明可能使用30 来制定数组的长度，由于该常量对所有的对象都是相同的，因此创建一个所有对象共享的对象是个不错的主意。
类似做法如下：

class Bakery
{
	private:
		const int Months = 12;
}
这种做法是错误的，类声明只是描述对象的形式，并没有创建对象

有两种方法实现这个目标，并且效果相同：
第一种方式是枚举：
在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称。

class Bakey
{
	private:
		enum {Months = 12};
}

用这种方式声明枚举并不会创建类数据成员，也就是说所有对象中都不包含枚举，另外Months只是符号名称，在作用域为整个类的代码中遇到它是，编译器将用12 来代替它，也就是在编译阶段就完成了。

第二种方式是使用关键子static
class Bakey {
	private:
		static const int Months = 12;
}
该常量将与其他静态变量存储在一起。而不是存储在对象中，因此只有一个Months常量，被所有的Bakery对象共享。

10.6.2 作用域内枚举 c++11
传统的枚举存在一些问题， 其中之一是两个枚举定义中的枚举量可能发生冲突 例如：
enum egg {small, medium, large}
enum t_shirt{small, medium, large}
两个定义如果位于相同的作用域内，他们将发生冲突，为了避免这种问题c++11提供了一种新的枚举，其枚举量的作用域为类，这种枚举的声明类似如下：

enum class egg {small, medium, large}
enum class t_shirt{small, medium, large}

class 可以使用struct代替
需要使用枚举名来限定枚举量。 看代码

#类继承

## 一个简单的基类
派生一个类：

```
class RatedPlayer: public TableTenPlaer
{
	

}
```

冒号指出TableTenPlaer类 是基类，RatedPlayer是派生类， public 是表示公有派生。 派生类对象包含基类对象，使用公有派生，基类的公有成员将成为派生类的公有成员，基类的私有部门也将成为派生类的一部分。
但只能通过基类的公有和保护方法访问。

RatedPlayer对象将具有以下特征：
派生类对象存储了基类的数据成员，派生类继承了基类的实现
派生类对象可以使用基类的方法，派生类继承了基类的接口

需要砸基类中添加什么呢：
派生类需要自己的构造函数。
派生类可以根据需要添加额外的数据成员和成员函数。

派生类不能直接访问基类的私有数据成员，而必须通过基类方法进程访问，例如 RatedPlayer构造函数不能直接设置继承的成员，而必须使用基类的公有方法来访问基类的私有成员，具体的说，派生类构造函数必须使用基类构造函数。
创建派生类对象是，程序首先创建基类对象，从概念是那个说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。c++使用成员初始化列表语法来完成这种工作。

有关派生类构造函数的要点如下：
1 首先创建基类对象
2 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数
3 派生类构造函数应该初始化派生类新增的数据成员。

创建派生类对象时，程序首先调用基类构造函数，然后调用派生类构造函数。基类构造函数负责初始化继承的数据成员，派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数，可以使用初始化列表语法指明要使用的基类的构造函数，否则将使用默认的基类构造函数。
派生类对象过期时，程序首先调用派生类析构函数，然后再调用基类构造函数。

使用派生类
要使用派生类，程序必须要能够访问基类声明。
派生类和基类之间的特殊关系：
派生类对象可以使用基类的方法。
基类指针可以在不进行显式类型转换的情况下指向派生类对象，基类引用可以在不进行显式类型转换的情况下引用派生类对象。
然而基类指针或者引用只能用于基类方法。不能用来调用派生类的方法。

不可以将基类对象和地址赋给派生类引用和指针。


继承 is-a 关系
派生类和基类之间的特殊关系是基于c++继承的底层模型的。 实际上c++有3中继承方式，公有继承，保护继承，和私有继承。
公有继承是最常见的方式，它建立 is-a 关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作也可以对派生类对象执行。

参考代码实现。


##多态公有继承：
RatedPlayer继承示例很简单，派生类对象使用基类的方法，而未做任何修改，可以会遇到以下情况，即希望同一个方法在派生类和基类中的行为是不同的，换句话说，方法的行为应取决于调用该方法的对象。这种比较复杂的行为称为多态。具有多种形态。
同一个方法的行为随上下文而异。两种重要的机制用于实现多态公有继承：
在派生类中重新定义基类方法
使用虚方法

如果方法是通过引用或者指针而不是对象调用的，如果没有使用关键字virtual，程序将根据引用类型或者指针类型选择方法，如果使用了virtual 关键字，程序将根据引用或指针指向的对象的类型来选择方法
这一点非常重要。

虚函数的这种行为非常方便，因此，经常在基类中将派生类会重新定义的方法声明为虚方法，方法在基类中被声明为虚方法后，它在派生类中将自动成为虚方法，在派生类中声明中使用virtual关键字来指出哪些函数是虚函数也不失为一个好方法。
基类声明了一个虚析构函数，这样做是为了确保释放派生类对象时，按正确的顺序调用析构函数。

如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的，这样程序将根据对象类型而不是引用类型或者指针类型来选择方法。为基类声明一个虚析构函数也是一种惯例。

记住派生类并不能直接访问基类的私有数据，而必须使用基类的公有方法才能访问这些数据，访问的方式取决于方法，构造函数是一种技术，而其他数据成员函数使用另一种技术。
派生类构造函数在初始化基类私有数据时，采用的是成员初始化列表方法。

非构造函数不能使用成员初始化列表语法，但派生类方法可以调用公有的基类方法。在派生类方法中，标准技术是使用域解析运算符来调用基类方法。

如果派生类中重新定义该方法，代码不必对方法使用域解析运算符。


引用变量：
引用看上去很像伪装表示的指针，实际上，引用还是不同于指针的，除了表示方法不同之外，差别之一就是：必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值。  一旦与某个变量关联起来，就将一直效忠于它。

即引用变量一直指向初始化时指向的地址。

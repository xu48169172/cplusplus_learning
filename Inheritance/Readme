#类继承

## 一个简单的基类
派生一个类：

```
class RatedPlayer: public TableTenPlaer
{
	

}
```

冒号指出TableTenPlaer类 是基类，RatedPlayer是派生类， public 是表示公有派生。 派生类对象包含基类对象，使用公有派生，基类的公有成员将成为派生类的公有成员，基类的私有部门也将成为派生类的一部分。
但只能通过基类的公有和保护方法访问。

RatedPlayer对象将具有以下特征：
派生类对象存储了基类的数据成员，派生类继承了基类的实现
派生类对象可以使用基类的方法，派生类继承了基类的接口

需要砸基类中添加什么呢：
派生类需要自己的构造函数。
派生类可以根据需要添加额外的数据成员和成员函数。

派生类不能直接访问基类的私有数据成员，而必须通过基类方法进程访问，例如 RatedPlayer构造函数不能直接设置继承的成员，而必须使用基类的公有方法来访问基类的私有成员，具体的说，派生类构造函数必须使用基类构造函数。
创建派生类对象是，程序首先创建基类对象，从概念是那个说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。c++使用成员初始化列表语法来完成这种工作。

有关派生类构造函数的要点如下：
1 首先创建基类对象
2 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数
3 派生类构造函数应该初始化派生类新增的数据成员。

创建派生类对象时，程序首先调用基类构造函数，然后调用派生类构造函数。基类构造函数负责初始化继承的数据成员，派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数，可以使用初始化列表语法指明要使用的基类的构造函数，否则将使用默认的基类构造函数。
派生类对象过期时，程序首先调用派生类析构函数，然后再调用基类构造函数。

使用派生类
要使用派生类，程序必须要能够访问基类声明。
派生类和基类之间的特殊关系：
派生类对象可以使用基类的方法。
基类指针可以在不进行显式类型转换的情况下指向派生类对象，基类引用可以在不进行显式类型转换的情况下引用派生类对象。
然而基类指针或者引用只能用于基类方法。不能用来调用派生类的方法。

不可以将基类对象和地址赋给派生类引用和指针。


继承 is-a 关系
派生类和基类之间的特殊关系是基于c++继承的底层模型的。 实际上c++有3中继承方式，公有继承，保护继承，和私有继承。
公有继承是最常见的方式，它建立 is-a 关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作也可以对派生类对象执行。

参考代码实现。


##多态公有继承：
RatedPlayer继承示例很简单，派生类对象使用基类的方法，而未做任何修改，可以会遇到以下情况，即希望同一个方法在派生类和基类中的行为是不同的，换句话说，方法的行为应取决于调用该方法的对象。这种比较复杂的行为称为多态。具有多种形态。
同一个方法的行为随上下文而异。两种重要的机制用于实现多态公有继承：
在派生类中重新定义基类方法
使用虚方法

如果方法是通过引用或者指针而不是对象调用的，如果没有使用关键字virtual，程序将根据引用类型或者指针类型选择方法，如果使用了virtual 关键字，程序将根据引用或指针指向的对象的类型来选择方法
这一点非常重要。

虚函数的这种行为非常方便，因此，经常在基类中将派生类会重新定义的方法声明为虚方法，方法在基类中被声明为虚方法后，它在派生类中将自动成为虚方法，在派生类中声明中使用virtual关键字来指出哪些函数是虚函数也不失为一个好方法。
基类声明了一个虚析构函数，这样做是为了确保释放派生类对象时，按正确的顺序调用析构函数。

如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的，这样程序将根据对象类型而不是引用类型或者指针类型来选择方法。为基类声明一个虚析构函数也是一种惯例。

记住派生类并不能直接访问基类的私有数据，而必须使用基类的公有方法才能访问这些数据，访问的方式取决于方法，构造函数是一种技术，而其他数据成员函数使用另一种技术。
派生类构造函数在初始化基类私有数据时，采用的是成员初始化列表方法。

非构造函数不能使用成员初始化列表语法，但派生类方法可以调用公有的基类方法。在派生类方法中，标准技术是使用域解析运算符来调用基类方法。

如果派生类中重新定义该方法，代码不必对方法使用域解析运算符。


引用变量：
引用看上去很像伪装表示的指针，实际上，引用还是不同于指针的，除了表示方法不同之外，差别之一就是：必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值。  一旦与某个变量关联起来，就将一直效忠于它。

即引用变量一直指向初始化时指向的地址。

##静态联编和动态联编

程序调用函数时，将使用哪个可执行代码块，编译器负责回答这个问题，将源代码中的函数调用解释为执行特定的函数代码快成为函数名联编。

在编译过程中联编称为静态联编，又称之为早期联编。 然而虚函数使这项工作变得更加困难，使用哪个函数时不能在编译时确定的，因为编译器不知道选择那种类型的对象。所以编译器必须生成能够在程序运行时选择正确的虚方法的代码。这被称为动态联编。又称为晚期联编。

将派生类引用或指针转换为基类引用或者指针被称为向上强制转换，这使公有继承不需要进行显式类型转换，该规则时is-a关系的一部分。 Brassplus对象都是Brass对象，因为它继承了Brass对象所有的数据成员和成员函数。所有对Brass对象执行的任何操作，都适用于Brassplus对象。因此为处理Brass引用而设计的函数可以对Brassplus对象执行同样的操作，而不必担心会导致任何问题。将指向对象的指针作为函数参数时，也是如此，向上强制转换时刻传递的。

向上强制转换是可传递的，也就是说从Brassplus派生出Brassplusplus类，则Brass指针或者引用可以引用Brass对象，Brassplus 对象 或 Brasspluplus对象。

将基类指针或者引用转换为派生类指针或者引用 称为向下强制转换。如果不使用显示类型转换，则向下强制转换是不允许的。

按值传递导致只将Brassplus对象的Brass部分传递给函数，但随引用和指针发生的隐式向上转换导致函数分别为Brass对象和Brassplus对象，使用Brass::viewacct() 和 Brassplus::viewacct()。

###虚成员函数和动态联编

编译器对非虚方法使用静态联编。

效率和概念模型。

首先来看效率，为使程序能够在运行阶段进程决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销。如果类不会用作基类则不需要动态联编。同样如果派生类不重新定义基类的任何方法，也不需要使用动态联编。在这些情况下使用静态联编更合理，效率更高。由于静态联编的效率更高，因此被设置为c++的默认选择。

如果要在派生类中重新定义基类的方法，则将它设置为 虚方法，否则，设置为非虚方法。

###虚函数工作原理

c++规定了虚函数的行为，但将实现留给了编译器。通常编译器处理虚函数的方法是：给每个对象增加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针。这种书虚称为虚函数表。virtual function table。虚函数表中存储了为类对象进程声明的虚函数的地址。 例如基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址，如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址。如果派生类定义了新的虚函素，则该函数的地址将该函数的地址也将被添加到虚函数表中。

调用虚函数时，程序将查看存储在对象中的虚函数表，然后转向相应的函数地址表，如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。

总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括：

每个对象都将增大，增大量为存储地址的空间

对于每个类，编译器都创建一个虚函数的地址表

对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。

###有关虚函数注意事项

####构造函数
构造函数不能时虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后派生类的构造函数将使用基类的一个构造函数。
####析构函数
析构函数应当是虚函数，除非类不用做基类。假设Employee是基类，singer是派生类。当singer对象过期时，必须调用～singer析构函数来释放内存。
代码如下：

````
Employee * pe = new singer;
delte pe
````

如果使用默认静态联编，delete 语句将调用～Employee析构函数。这将释放singer 对象中的Employee部分指向的内存，但不会释放新的类成员指向的内存。如果析构函数是虚的，则上述代码将先调用～singer析构函数释放有singer组件指向的内存，然后调用～employee析构函数来释放有employee组件指向的内存。

这意味着，即使基类不需要显式析构函数服务，也不应依赖于默认构造函数，而应提供虚析构函数，即使它不执行任何操作。

````
virtual ~Bassclass(){}
````

通常应给基类提供一个虚析构函数并非错误，即使这个类不用做基类，即使它不需要析构函数。

####友元

友元不能是虚函数，因为友元不是类成员，而只有成员才能时虚函数，如果由于这个原因引起了设计问题，可以通过友元函数使用虚成员函数来解决。

####没有重新定义
派生类没有重新定义函数，将使用该函数的基类版本，如果派生类位于派生链中，则将使用最新的虚函数版本。

####重新定义将隐藏方法
重新定义不会生成函数的两个重载版本，而是隐藏了接受一个int 参数的基类版本。 总之重新继承的方法并不是重载，如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法。

这引出了两条经验规则，第一重新定义继承的方法，应确保于原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。

第二，如果基类声明被重载了，则应该在派生类中重新定义所有的基类版本。

##访问控制：pretected
protected 与 private 相似，在类外只能用公有类成员来访问protected部分中的类成员。private 与protected 之间的区别在于只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员。但不能直接访问基类的私有成员。


##抽象基类

c++通过使用纯虚函数提供未实现的函数。纯虚函数声明的结尾处为=0
当类声明中包含纯虚函数时，则不能创建该类的对象。这里的理念是，包含纯虚函数的类只用作基类。要成为真正的抽象基类，必须至少包含一个纯虚函数。原型中的=0 使虚函数称为纯虚函数。

可以将抽象基类看作是一种必须实施的接口，抽象基类要求具体派生覆盖其纯虚函数  迫使派生类遵循抽象基类设置的接口规则。

##继承和动态内存分配

如果基类使用动态内存分配，并重新定义赋值运算符和复制构造函数。将怎样影响派生类的实现，取决于派生类的属性：

###第一种情况：派生类不使用new
假设基类使用了动态内存分配，声明中包含了构造函数使用new时需要的特殊方法：析构函数，复制构造函数，和重载赋值运算符。
而派生类没有使用new。 则不需要为派生类定义显式析构函数，复制构造函数和赋值运算符。
###第二种情况：派生类使用new
假设派生类使用了new， 这种情况下，必须为派生类定义显式析构函数，复制构造函数和赋值运算符。

总之 当基类和派生类都采用动态内存分配时，派生类的析构函数 复制构造函数 赋值运算符都必须使用相应的基类方法来处理元素。这种要求通过三种不同的方式来满足的。

对于析构函数，这是自动完成的。

对于复制构造函数，这种通过在初始化成员列表中调用基类的复制构造函数来完成的。如果不这样做，将自动调用基类的默认构造函数。

对于赋值运算符，这是通过使用域解析运算符显式调用基类的赋值运算符来完成的。

